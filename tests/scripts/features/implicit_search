#                                                                    -*-perl-*-

$description = "Test implicit rule search.";

$details = "";


# sv 48643
# Each test has a %.c rule ahead of %.f rule.
# hello.f exists and hello.c is missing.

unlink('hello.c', 'hello.tsk', 'hello.o');



# Run every test with and without a suffix.
my @suffixes = ('', '.o');
# Run every test with single and double colon rules.
my @rules = ('', ':');

touch('hello.f');

for my $s (@suffixes) {
for my $r (@rules) {
touch('hello.f');


# Test that make finds the intended implicit rule based on existence of a
# prerequisite in the filesystem.
#
# '%.o: %.c' rule is skipped and '%.o: %.f' rule is chosen.
run_make_test("
all: hello$s
%$s:$r %.c; \$(info hello.c)
%$s:$r %.f; \$(info hello.f)
", '', "hello.f\n#MAKE#: Nothing to be done for 'all'.");

# Test that make finds the intended implicit rule based on the explicit
# prerequisite of the top goal and despite the existence of a
# prerequisite in the filesystem.
#
# hello.c is an explicit prerequisite of the top target (hello.o or hello).
# hello.c ought to exist.
# hello.c prerequisite causes '%.o: %.c' rule to be chosen.
run_make_test("
hello$s: hello.c
%$s:$r %.c; \$(info hello.c)
%$s:$r %.f; \$(info hello.f)
",
'',
"#MAKE#: *** No rule to make target 'hello.c', needed by 'hello$s'.  Stop.\n",
512);

# Test that make finds the intended implicit rule when the implicit
# prerequisite matches a target of an unrelated rule and despite the existence
# of a prerequisite of the other rule candidate in the filesystem.
#
# hello.c matches 'hello.c:' rule. This makes hello.c a target and thus ought
# to exist.
# hello.c prerequisite causes '%.o: %.c' rule to be chosen.
run_make_test("
all: hello$s
%$s:$r %.c; \$(info hello.c)
%$s:$r %.f; \$(info hello.f)
hello.c:; false
", '', "false\n#MAKE#: *** [#MAKEFILE#:5: hello.c] Error 1\n", 512);

# Test that make finds the intended implicit rule based on existence of a
# prerequisite in the filesystem, even when the prerequisite of another
# candidate rule is mentioned explicitly on an unrelated rule.
#
# '%.o: %.c' rule is skipped and '%.o: %.f' rule is chosen, even though hello.c
# is mentioned explicitly on 'unrelated: hello.c'.
# ought-to-exist does not apply to hello.c.
run_make_test("
all: hello$s
%$s:$r %.c; \$(info hello.c)
%$s:$r %.f; \$(info hello.f)
unrelated: hello.c
", '', "hello.f\n#MAKE#: Nothing to be done for 'all'.");

# Test that make finds the intended implicit rule based on existence of a
# prerequisite in the filesystem.
#
# '%.o: %.c' rule is skipped and '%.o: %.f' rule is chosen.
# Despite '%.o: %.c hello.c' rule having explicit prerequisite hello.c.
# ought-to-exist does not apply to hello.c.
run_make_test("
all: hello$s
%$s:$r %.c hello.c; \$(info hello.c)
%$s:$r %.f; \$(info hello.f)
", '', "hello.f\n#MAKE#: Nothing to be done for 'all'.");

# '%.o: %.c' rule is skipped and '%.o: %.f' rule is chosen.
# '%.o: %.f hello.f' rule has explicit prerequisite hello.f.
# ought-to-exist does not apply to hello.c.
run_make_test("
all: hello$s
%$s:$r %.c; \$(info hello.c)
%$s:$r %.f hello.f; \$(info hello.f)
", '', "hello.f\n#MAKE#: Nothing to be done for 'all'.");

# Rule '%: %.f' is chosen, because '%: %.f' requires no intermediates.
# '%: %.c', on the other hand, requires intemediate hello.c to be built by the
# default rule.
run_make_test("
all: hello$s
%$s:$r %.c; \$(info \$<)
%$s:$r %.f; \$(info \$<)
.DEFAULT:; true
unrelated: hello.c
", '', "hello.f\n#MAKE#: Nothing to be done for 'all'.");


unlink('hello.f');
# hello.f is missing.
# This time both hello.c and hello.f are missing and both '%: %.c' and '%: %.f'
# require an intermediate.
# The default rule builds intemerdiate hello.c.
# '%: %.c' rule is chosen to build hello.
run_make_test("
all: hello$s
%$s:$r %.c; \$(info \$<)
%$s:$r %.f; \$(info \$<)
.DEFAULT:; false
unrelated: hello.c
", '', "false\n#MAKE#: *** [#MAKEFILE#:5: hello.c] Error 1\n", 512);

# hello.f is missing.
# No rule is found, because hello.c is not mentioned explicitly.
run_make_test("
all: hello$s
%$s:$r %.c; \$(info \$<)
%$s:$r %.f; \$(info \$<)
.DEFAULT:; \@echo default making \$\@ && false
",
'',
"default making hello$s\n#MAKE#: *** [#MAKEFILE#:5: hello$s] Error 1\n",
512);

}
}

# Almost the same tests as above, but this time an intermediate is built.

touch('hello.f');
for my $s (@suffixes) {
for my $r (@rules) {

my $result = "#MAKE#: *** No rule to make target 'hello.tsk', needed by 'all'.  Stop.\n";
my $rcode = 512;
if ($s or $r) {
    $result = "hello.f\nhello.tsk\n#MAKE#: Nothing to be done for 'all'.";
    $rcode = 0;
}

run_make_test("
all: hello.tsk
%.tsk: %$s; \$(info hello.tsk)
%$s:$r %.c; \$(info hello.c)
%$s:$r %.f; \$(info hello.f)
", '', "$result", $rcode);

run_make_test("
all: hello.tsk
%.tsk: %$s hello$s; \$(info hello.tsk)
%$s:$r %.c; \$(info hello.c)
%$s:$r %.f; \$(info hello.f)
", '', $result, $rcode);

run_make_test("
all: hello.tsk
%.tsk: %$s; \$(info hello.tsk)
%$s:$r %.c hello$s; \$(info hello.c)
%$s:$r %.f; \$(info hello.f)
", '', $result, $rcode);

}
}

for my $r (@rules) {

# Circular dependency hello.o <- hello.tsk is dropped.
run_make_test("
all: hello.tsk
%.tsk: %.o; \$(info hello.tsk)
%.o:$r %.c; \$(info hello.c)
%.o:$r %.f %.tsk; \$(info hello.f)
",
'-R',
"#MAKE#: Circular hello.o <- hello.tsk dependency dropped.\nhello.f\nhello.tsk\n#MAKE#: Nothing to be done for 'all'.");

}


for my $s (@suffixes) {
for my $r (@rules) {

run_make_test("
all: hello.tsk
hello$s: hello.c
%.tsk: %$s; \$(info hello.tsk)
%$s:$r %.c; \$(info hello.c)
%$s:$r %.f; \$(info hello.f)
",
'',
"#MAKE#: *** No rule to make target 'hello.c', needed by 'hello$s'.  Stop.\n",
512);
}
}

for my $s (@suffixes) {
for my $r (@rules) {

my $result = "#MAKE#: *** No rule to make target 'hello.tsk', needed by 'all'.  Stop.\n";
if ($s or $r) {
    $result = "false\n#MAKE#: *** [#MAKEFILE#:6: hello.c] Error 1\n";
}

run_make_test("
all: hello.tsk
%.tsk: %$s; \$(info hello.tsk)
%$s:$r %.c; \$(info hello.c)
%$s:$r %.f; \$(info hello.f)
hello.c:; false
", '', $result, 512);
}
}


for my $s (@suffixes) {
for my $r (@rules) {

run_make_test("
all: hello.tsk
%.tsk: %$s; \$(info hello.tsk)
%$s:$r %.c; \$(info hello.c)
%$s:$r %.f; \$(info hello.f)
unrelated: hello$s
", '', "hello.f\nhello.tsk\n#MAKE#: Nothing to be done for 'all'.");
}
}

for my $s (@suffixes) {
for my $r (@rules) {

my $result = "#MAKE#: *** No rule to make target 'hello.tsk', needed by 'all'.  Stop.\n";
my $rcode = 512;
if ($s or $r) {
    $result = "hello.f\nhello.tsk\n#MAKE#: Nothing to be done for 'all'.";
    $rcode = 0;
}

run_make_test("
all: hello.tsk
%.tsk: %$s; \$(info hello.tsk)
%$s:$r %.c; \$(info hello.c)
%$s:$r %.f hello.f; \$(info hello.f)
", '', $result, $rcode);
}
}



touch ('hello.f');
# Test implicit search of builtin rules.

# %: %.c (and other builtin rules) are skipped.
# %: %.f is chosen.
run_make_test(q!
all: hello
!, 'FC="@echo f77" OUTPUT_OPTION=', "f77 hello.f -o hello\n");

# %.o: %.c (and other builtin rules) are skipped.
# %.o: %.f is chosen.
run_make_test(q!
all: hello.o
!, 'FC="@echo f77" OUTPUT_OPTION=', "f77 -c hello.f\n");


# %: %.c is chosen.
# hello.c is an explicit prerequisite of the top target hello.
# hello.c ought to exist.
# hello.c prerequisite causes '%: %.c' rule to be chosen.
run_make_test(q!
hello: hello.c
!,
'FC="@echo f77" OUTPUT_OPTION=',
"#MAKE#: *** No rule to make target 'hello.c', needed by 'hello'.  Stop.\n",
512);

# %.o: %.c is chosen.
# hello.c is an explicit prerequisite of the top target hello.o.
# hello.c ought to exist.
# hello.c prerequisite causes '%.o: %.c' rule to be chosen.
run_make_test(q!
hello.o: hello.c
!,
'FC="@echo f77" OUTPUT_OPTION=',
"#MAKE#: *** No rule to make target 'hello.c', needed by 'hello.o'.  Stop.\n",
512);

# %: %.c (and other builtin rules) are skipped.
# %: %.f is chosen.
# ought-to-exist does not apply to hello.c.
run_make_test(q!
all: hello
unrelated: hello.c
!, 'FC="@echo f77" OUTPUT_OPTION=', "f77 hello.f -o hello\n");

# %.o: %.c (and other builtin rules) are skipped.
# %.o: %.f is chosen.
# ought-to-exist does not apply to hello.c.
run_make_test(q!
all: hello.o
unrelated: hello.c
!, 'FC="@echo f77" OUTPUT_OPTION=', "f77 -c hello.f\n");

# builtin rule %.o: %.f is removed.
# %.o: %.c (and other builtin rules) are skipped, because hello.c is missing.
# ought-to-exist does not apply to hello.c.
# %.o: %.c is chosen as a compatibility rule, because of hello.c.
run_make_test(q!
all: hello.o
unrelated: hello.c
%.o: %.f
!,
'',
"#MAKE#: *** No rule to make target 'hello.c', needed by 'hello.o'.  Stop.\n",
512);


# sv 17752.
# In this test the builtin match-anything rule '%: %.f' is used to build
# intermediate hello from hello.f, because hello is mentioned explicitly in
# the makefile.
run_make_test(q!
all: hello.tsk
%.tsk: %; $(info $@ from $<)
unrelated: hello
!,
'FC="@echo f77" OUTPUT_OPTION=',
"f77 hello.f -o hello\nhello.tsk from hello\n");

# In this test the builtin match-anything rule %: %.f cannot be used to build
# intermediate hello from hello.f, because hello is not mentioned explicitly in
# the makefile.
run_make_test(q!
all: hello.tsk
%.tsk: %; $(info $@ from $<)
!,
'FC="@echo f77" OUTPUT_OPTION=',
"#MAKE#: *** No rule to make target 'hello.tsk', needed by 'all'.  Stop.\n",
512);

unlink('bye.o', 'bye.tsk');
# sv 21670.
# Default recipe is used to build bye.o.
run_make_test(q!
all: bye.tsk
%.tsk: %.o; $(info $@ from $<)
.DEFAULT:; $(info bye.o)
unrelated: bye.o
!, '', "bye.o\nbye.tsk from bye.o\n#MAKE#: Nothing to be done for 'all'.");

unlink('hello.f');

# This tells the test driver that the perl test script executed properly.
1;
