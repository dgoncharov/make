#                                                                    -*-perl-*-

$description = "Test implicit rule search.";

$details = "";


# sv 48643
# Each test has a %.c rule ahead of %.f rule.
# hello.f exists and hello.c is missing.

unlink('hello.c', 'hello.tsk', 'hello.o');



# Run every test with and without a suffix.
my @suffixes = ('', '.o');
# Run every test with single and double colon rules.
my @rules = ('', ':');

for my $s (@suffixes) {
for my $r (@rules) {
touch('hello.f');


# Test that make finds the intended implicit rule based on existence of a
# prerequisite in the filesystem.
#
# '%.o: %.c' rule is skipped and '%.o: %.f' rule is chosen.
run_make_test("
all: hello$s
%$s:$r %.c; \$(info hello.c)
%$s:$r %.f; \$(info hello.f)
", '', "hello.f\n#MAKE#: Nothing to be done for 'all'.");

# Test that make finds the intended implicit rule based on the explicit
# prerequisite of the top goal and despite the existence of a
# prerequisite in the filesystem.
#
# hello.c is an explicit prerequisite of the top target (hello.o or hello).
# hello.c ought to exist.
# hello.c prerequisite causes '%.o: %.c' rule to be chosen.
run_make_test("
hello$s: hello.c
%$s:$r %.c; \$(info hello.c)
%$s:$r %.f; \$(info hello.f)
",
'',
"#MAKE#: *** No rule to make target 'hello.c', needed by 'hello$s'.  Stop.\n",
512);

# Test that make finds the intended implicit rule when the implicit
# prerequisite matches a target of an unrelated rule and despite the existence
# of a prerequisite of the other rule candidate in the filesystem.
#
# hello.c matches 'hello.c:' rule. This makes hello.c a target and thus ought
# to exist.
# hello.c prerequisite causes '%.o: %.c' rule to be chosen.
run_make_test("
all: hello$s
%$s:$r %.c; \$(info hello.c)
%$s:$r %.f; \$(info hello.f)
hello.c:; false
", '', "false\n#MAKE#: *** [#MAKEFILE#:5: hello.c] Error 1\n", 512);

# Test that make finds the intended implicit rule based on existence of a
# prerequisite in the filesystem, even when the prerequisite of another
# candidate rule is mentioned explicitly on an unrelated rule.
#
# '%.o: %.c' rule is skipped and '%.o: %.f' rule is chosen, even though hello.c
# is mentioned explicitly on 'unrelated: hello.c'.
# ought-to-exist does not apply to hello.c.
run_make_test("
all: hello$s
%$s:$r %.c; \$(info hello.c)
%$s:$r %.f; \$(info hello.f)
unrelated: hello.c
", '', "hello.f\n#MAKE#: Nothing to be done for 'all'.");

# Test that make finds the intended implicit rule based on existence of a
# prerequisite in the filesystem.
#
# '%.o: %.c' rule is skipped and '%.o: %.f' rule is chosen.
# Despite '%.o: %.c hello.c' rule having explicit prerequisite hello.c.
# ought-to-exist does not apply to hello.c.
run_make_test("
all: hello$s
%$s:$r %.c hello.c; \$(info hello.c)
%$s:$r %.f; \$(info hello.f)
", '', "hello.f\n#MAKE#: Nothing to be done for 'all'.");

# Test that make finds the intended implicit rule based on existence of a
# prerequisite in the filesystem.
#
# '%.o: %.c' rule is skipped and '%.o: %.f' rule is chosen.
# '%.o: %.f hello.f' rule has explicit prerequisite hello.f.
# ought-to-exist does not apply to hello.c.
run_make_test("
all: hello$s
%$s:$r %.c; \$(info hello.c)
%$s:$r %.f hello.f; \$(info hello.f)
", '', "hello.f\n#MAKE#: Nothing to be done for 'all'.");

# Rule '%: %.f' is chosen, because '%: %.f' requires no intermediates.
run_make_test("
all: hello$s
%$s:$r %.c; \$(info \$<)
%$s:$r %.f; \$(info \$<)
.DEFAULT:; true
unrelated: hello.c
", '', "hello.f\n#MAKE#: Nothing to be done for 'all'.");


unlink('hello.f');
# hello.f is missing.
# the default rule builds intemerdiate hello.c.
# '%: %.c' rule is chosen to build hello.
run_make_test("
all: hello$s
%$s:$r %.c; \$(info \$<)
%$s:$r %.f; \$(info \$<)
.DEFAULT:; false
unrelated: hello.c
", '', "false\n#MAKE#: *** [#MAKEFILE#:5: hello.c] Error 1\n", 512);

# hello.f is missing.
# No rule is found, because hello.c is not mentioned explicitly.
run_make_test("
all: hello$s
%$s:$r %.c; \$(info \$<)
%$s:$r %.f; \$(info \$<)
.DEFAULT:; \@echo default making \$\@ && false
",
'',
"default making hello$s\n#MAKE#: *** [#MAKEFILE#:5: hello$s] Error 1\n",
512);

}
}

touch ('hello.f');
# Test implicit search of builtin rules.
my %suf = ('' => 'f77 hello.f -o hello', '.o' => 'f77 -c hello.f');
#
while (($s, $r) = each (%suf)) {
# %: %.c (and other builtin rules) are skipped.
# %: %.f is chosen.
run_make_test("
all: hello$s
", 'FC="@echo f77" OUTPUT_OPTION=', "$r\n");

# %: %.c is chosen.
# hello.c is an explicit prerequisite of the top target (hello.o or hello).
# hello.c ought to exist.
# hello.c prerequisite causes '%: %.c' rule to be chosen.
run_make_test("
hello$s: hello.c
",
'FC="@echo f77" OUTPUT_OPTION=',
"#MAKE#: *** No rule to make target 'hello.c', needed by 'hello$s'.  Stop.\n",
512);

# %: %.c (and other builtin rules) are skipped.
# %: %.f is chosen.
# ought-to-exist does not apply to hello.c.
run_make_test("
all: hello$s
unrelated: hello.c
", 'FC="@echo f77" OUTPUT_OPTION=', "$r\n");
}

# sv 17752.
# Ensure match anything rules are allowed to build intermediates as long as the
# intermediate file is mentioned explicitly.
# In this test the builtin match-anything rule '%: %.f' is used to build
# intermediate hello from hello.f, because hello is mentioned explicitly in
# the makefile.
run_make_test(q!
all: hello.tsk
%.tsk: %; $(info $@ from $<)
unrelated: hello
!,
'FC="@echo f77" OUTPUT_OPTION=',
"f77 hello.f -o hello\nhello.tsk from hello\n");

# Ensure match anything rules are not allowed to build intermediates unless the
# intermediate file is mentioned explicitly.
# In this test the builtin match-anything rule %: %.f cannot be used to build
# intermediate hello from hello.f, because hello is not mentioned explicitly in
# the makefile.
run_make_test(q!
all: hello.tsk
%.tsk: %; $(info $@ from $<)
!,
'FC="@echo f77" OUTPUT_OPTION=',
"#MAKE#: *** No rule to make target 'hello.tsk', needed by 'all'.  Stop.\n",
512);

unlink('bye.o', 'bye.tsk');
# sv 21670.
# Default recipe is used to build bye.o.
run_make_test(q!
all: bye.tsk
%.tsk: %.o; $(info $@ from $<)
.DEFAULT:; $(info bye.o)
unrelated: bye.o
!, '', "bye.o\nbye.tsk from bye.o\n#MAKE#: Nothing to be done for 'all'.");

unlink('hello.f');

# This tells the test driver that the perl test script executed properly.
1;
