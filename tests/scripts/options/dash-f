$description = "The following test tests that if you specify greater \n"
              ."than one '-f makefilename' on the command line, \n"
              ."that make concatenates them.  This test creates three \n"
              ."makefiles and specifies all of them with the -f option \n"
              ."on the command line.  To make sure they were concatenated, \n"
              ."we then call make with the rules from the concatenated \n"
              ."makefiles one at a time.  Finally, it calls all three \n"
              ."rules in one call to make and checks that the output\n"
              ."is in the correct order.";

$makefile2 = &get_tmpfile;
$makefile3 = &get_tmpfile;

open(MAKEFILE,"> $makefile");

# The Contents of the MAKEFILE ...

print MAKEFILE "all: \n";
print MAKEFILE "\t\@echo This is the output from the original makefile\n";

# END of Contents of MAKEFILE

close(MAKEFILE);

# Create a second makefile
open(MAKEFILE,"> $makefile2");
print MAKEFILE "TWO: \n";
print MAKEFILE "\t\@echo This is the output from makefile 2\n";
close(MAKEFILE);

# Create a third makefile
open(MAKEFILE,"> $makefile3");
print MAKEFILE "THREE: \n";
print MAKEFILE "\t\@echo This is the output from makefile 3\n";
close(MAKEFILE);


# Create the answer to what should be produced by this Makefile
$answer = "This is the output from the original makefile\n";

# Run make to catch the default rule
&run_make_with_options($makefile,"-f $makefile2 -f $makefile3",&get_logfile,0);

&compare_output($answer,&get_logfile(1));


# Run Make again with the rule from the second makefile: TWO
$answer = "This is the output from makefile 2\n";

&run_make_with_options($makefile,"-f $makefile2 -f $makefile3 TWO",&get_logfile,0);

&compare_output($answer,&get_logfile(1));


# Run Make again with the rule from the third makefile: THREE

$answer = "This is the output from makefile 3\n";
&run_make_with_options($makefile,
                       "-f $makefile2 -f $makefile3 THREE",
                       &get_logfile,
                       0);
&compare_output($answer,&get_logfile(1));


# Run Make again with ALL three rules in the order 2 1 3 to make sure
# that all rules are executed in the proper order

$answer = "This is the output from makefile 2\n";
$answer .= "This is the output from the original makefile\n";
$answer .= "This is the output from makefile 3\n";
&run_make_with_options($makefile,
                       "-f $makefile2 -f $makefile3 TWO all THREE",
		       &get_logfile,
                       0);
&compare_output($answer,&get_logfile(1));


# sv 62118.
# Test that make correctly parses all possible syntaxes to pipe make code to
# the standard input.
# The contents of hello.mk is read from the standard input.
# -f bye.mk is also passed.
# During the first iteration of the loop below the invocation is equivalent to
# 'make -f bye.mk -f- all <hello.mk',
# during the second
# 'make -f bye.mk -f - all <hello.mk',
# etc.

my $hello = 'hello.mk';
my $bye = 'bye.mk';
my $byesrc = 'bye.mk.src';

unlink($hello, $bye, $byesrc);

open(BYE, "> $bye") || die "$0: cannot open $bye for writing: $!";
printf BYE 'def:; $(info bye, world)
bye.mk: bye.mk.src; touch $@
bye.mk.src:; touch $@
'  || die "$0: cannot write to $bye: $!";;
close(BYE);

open(HELLO,"> $hello") || die "$0: cannot open $hello for writing: $!";
printf HELLO 'all:; $(info hello, world)' ||
   die "$0: cannot write to $hello: $!";
close(HELLO);


my $answer =
"touch bye.mk.src
touch bye.mk
hello, world
make: 'all' is up to date.\n";


my @opts = ('-f- all', '-f - all', '-Rf- all', '-Rf - all',
            '--file=- all', '--file - all',
            '--makefile=- all', '--makefile - all');
for my $opt (@opts) {
    unlink($byesrc);
    close(STDIN);
    open(STDIN, "<", $hello) || die "$0: cannot open $hello for reading: $!";
    # Ensure the newly created bye.src.mk is newer than bye.mk.
    &utouch(-600, $bye);
    &run_make_with_options($bye, $opt, &get_logfile);
    &compare_output($answer, &get_logfile(1));
}

# Incorrect order of options. -R follows -f.
# Invocation of make is equivalent to
# echo 'all:; $(info hello, world)' | make -f bye.mk -fR - all
# There is bye.mk, but there is no 'R'.
# make runs the recipes from bye.mk and prints the error about missing 'R'.
my $answer =
"make: R: No such file or directory
touch bye.mk.src
touch bye.mk
make: *** No rule to make target 'R'.  Stop.
";

unlink($byesrc);
close(STDIN);
open(STDIN, "<", $hello) || die "$0: cannot open $hello for reading: $!";
# Ensure the newly created bye.src.mk is newer than bye.mk.
&utouch(-600, $bye);
&run_make_with_options($bye, '-fR - all', &get_logfile, 512);
&compare_output($answer, &get_logfile(1));


# Double -f.
my @opts = ('-f- -f-', '-f - -f -', '-f- -f -', '-f - -f-',
            '-f- --file=-', '-f- --file -', '-f - --file=-', '-f - --file -',
            '-f- --makefile=-', '-f- --makefile -',
            '-f - --makefile=-', '-f - --makefile -',
            '--file=- --makefile=-', '--file=- --makefile -',
            '--file - --makefile=-', '--file - --makefile -');

my $answer =
    "#MAKE#: *** Makefile from standard input specified twice..  Stop.\n";
$answer = &subst_make_string($answer);
for my $opt (@opts) {
    &run_make_with_options($bye, $opt, &get_logfile, 512);
    &compare_output($answer, &get_logfile(1));
}

# -f is not followed by filename.
my @opts = ('-f', '--file', '--makefile');
my $answer = "/requires an argument/";
for my $opt (@opts) {
    &run_make_with_options($bye, $opt, &get_logfile, 512);
    &compare_output($answer, &get_logfile(1));
}

#unlink($hello, $bye, $byesrc);


# This tells the test driver that the perl test script executed properly.
1;
